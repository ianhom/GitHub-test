/************************************************************/
ucos ii简介
/************************************************************/
配置文件：
INCLUDES.H //一般不需要修改
OS_CFG.H//一般需要根据程序需求修改其常量的内容


实时操作系统通过一系列的软件管理让一个CPU形成多个线程，就好像多个CPU一起在执行一样，实际上是多个线程并行运行。



什么是任务？
在实时多任务系统下运行的应用软件程序就是任务，在没有使用OS的前后台系统中，我们可以任务main函数以及通过main函数调用的全体函数为一个任务。
    通常将“并行程序执行的基本逻辑单位”成为任务，也就是说任务是可以被分割为独立的且可以并行执行的基本逻辑单位程序。一个任务的程序是顺序执行的，而不同任务的程序却是并行执行的，任务必须包括相互独立和并行执行两方面。

什么是独立？
独立指任务不能彼此直接调用，也不能直接进行数据交换。

什么是并行执行？
假设操作系统为每个任务虚拟了一个CPU，每个CPU执行各自的任务，为并行执行。

任务的状态：
ucos任务有5中状态：睡眠，就绪，运行，等待，被中断

在操作系统中，程序设计就像记流水账
在后头系统中，一个模块可以调用另一个模块，因此各模块在执行时间上相互错开，且信息传递同步

在进入首个运行的任务之前要禁止产生任何受操作系统管理的中断，包括节拍定时器的中断，因为这类中断产生后操作系统会对任务进行扫描，并尝试进行任务切换，将导致程序出错，甚至引起系统崩溃。所以通常将硬件初始化函数放在首个运行任务开始的地方执行。

ucos是通过任务控制块来管理任务的，任务控制块是一个基于链表的数据结构，任务控制块主要用于记录任务的堆栈栈顶指针，指向下一个任务控制块的指针，任务等待的延时时间，任务的当前状态标志与任务的优先级别等一些与任务管理有关的属性。
当任务的CPU使用权被剥夺时，UCOS用任务控制块来保存该任务的状态，从而保证任务重新获得CPU使用权时从断点处执行。

任务控制块，OSTCBL[]成员：OSTCBStkPtr/OSTCBNext/OSTCBDly/OSTCBStat：
/OSTCBPrio:任务优先级变量，变量值越小，任务优先级越高
OSTCBX/OSTCBY/OSTCBBitX/OSTCBBitY



ucos最小内核定义了4个指针，一个数组和一个指针数组。 
OSTCBCur:指向 当前任务控制块的指针
OSTCBFreeList:空任务控制块 链表的表头指针
OSTCBHighRdy：指向 将要运行最高优先级任务控制块的指针
OSTCBList：已使用任务控制块链表的表头指针

OSTCBPriTbl[]：任务控制块优先级表，专门用来存放指向各任务控制块的指针，并按照任务优先级将这些指针存放在数组的各个元素里。

OSTCBTbl[]：任务控制块数组，所有的任务控制块都保存在这个数组中。



任务就绪算法是指任务准备运行但CPU没空，任务等待运行的状态。
    任务就绪算法涉及“任务就绪表OSRdyTbl、映射表OSMapTbl、优先级判定表OSUnMapTbl、变量OSRdyGrp和任务优先级prio”其中映射表OSMapTbl和优先级判别表OSUnMapTbl是2个常数表，用于查表算法。


前后台系统程序框架：
main()
{
  Peripheral_Init();
  while(1)
  {
      process();
  }
}

除了顺序执行的前后台系统外，使用时间片轮询法，指多个任务以一定的频率执行。
任务编写方式,将下述代码放在while(1)中：
if(Task_delay[i]==0)
{
    Task[i];
    Task_delay[i]=xx;
}
有多少个任务就有多少个delay。
在中断服务程序中将Task_delay数组中的所有元素进行减1操作。
void Interrrupte_Handler(void)
{
    int i;
    for(i=0;i<TASK_NUM;i++)
    {
        if(Task_delay[i])
        {
           Task_delay[i]--;
        }
    }
}

实时操作系统中比较重要的是实时性，即要求系统有比较快的响应速度和执行速度。
如果一个任务执行时间过长，那么会影响到其他任务的执行，不适合实时性要求高
的系统。嵌入式实时操作系统能随时切换到优先级比较高的任务，不管当前任务是
否放弃CPU的使用权，只要任务的优先级足够高，那么这个任务的实时性还是非常好
的。实时操作系统分为硬实时和软实时，硬实时要求在规定的时间内必须完成任务，
软实时要求越快完成越好。实时操作系统分为不可剥夺型和可剥夺型，不可剥夺型
内核只有在当前线程放弃CPU使用权之后其他的线程才可以占用CPU，而可剥夺型内
核只要存在更高优先级的线程就绪，低优先级的线程就会被打断，高优先级线程占有
CPU，UCOS属于可剥夺型内核。
在可剥夺型系统中，任务代码随时都可能被打断去执行另一个任务或者中断，这个时候
任务可能正在进行往一个变量写入数值的过程，而这个过程是需要多个指令的，如果
写入过程只进行到一半任务就被打断了，而这个变量有可能在中断或者其他任务中被
读取，那么会读到一个错误的值，所以写入的这个过程不能被打断，一般来说，我们有
两种方式保护临界段。一个是关中断，另一个是锁调度器。锁住调度器可以防止其他
任务访问临界代码，但是不能防止中断访问临界段代码。
